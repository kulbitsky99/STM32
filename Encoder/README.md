## Задание 06 "exti_systick"

В этом задании предлагается подключить энкодер для управления семисегментным индикатором.

## EXTI и кнопка

Прежде чем переходить к энкодеру вам предлагается поработать с модулем EXTI на более простом примере. 
Возьмите за основу пустой проект и добавьте функцию инициализации системы тактирования `rcc_config`,
которую можно взять из прошлых заданий. Далее необходимо вызвать её в `main`.
Также добавьте следующий список заголовочных файлов:

```c
#include "stm32f0xx_ll_rcc.h"
#include "stm32f0xx_ll_system.h"
#include "stm32f0xx_ll_bus.h"
#include "stm32f0xx_ll_gpio.h"
#include "stm32f0xx_ll_exti.h"
```

Файл `stm32f0xx_ll_exti.h` необходим для работы с модулем внешних прерываний. Заголовочные файлы `stm32f0xx_ll_utils.h` и `stm32f0xx_ll_cortex.h` нужны для работы с системным таймером. 

Напишите программу, которая будет переключать состояние светодиода при нажатии на кнопку, используя внешнее прерывание. Воспользуйтесь кнопкой, подключенной ко входу `0` порта `GPIOA`. Данная кнопка установлена на отладочной плате с надписью `USER`.

В первую очередь проинициализируйте линию `0` модуля `EXTI`. Для этого необходимо сконфигурировать мультиплексор выбора порта для линии `0` в регистрах `SYSCFG` (стр. 214 [справочного описание периферии](https://github.com/edosedgar/stm32f0_ARM/blob/master/docs/stm32f0xx_rm.pdf)).
Инициализацию выполните в функции `exti_config`:

```c
/*
 * Не забудьте про тактирование!
 */
LL_APB1_GRP2_EnableClock(LL_APB1_GRP2_PERIPH_SYSCFG);
/*
 * Подключение порта GPIOA для линии 0
 */
LL_SYSCFG_SetEXTISource(LL_SYSCFG_EXTI_PORTA, LL_SYSCFG_EXTI_LINE0);
```

Далее включите обработку нулевой линии в модуле `EXTI`:

```c
LL_EXTI_EnableIT_0_31(LL_EXTI_LINE_0);
```

После этого настройте по какому фронту сигнал будет обрабатываться: нарастающему или спадающему, или по обоим. Кнопка имеет
подтягивающий резистор на землю, поэтому при нажатии будет генерировать нарастающий фронт.

```c
LL_EXTI_EnableRisingTrig_0_31(LL_EXTI_LINE_0);
```

Последним шагом сконфигурируйте линию прерывания `EXTI0_1_IRQn` в модуле `NVIC`:

```c
NVIC_EnableIRQ(EXTI0_1_IRQn);
NVIC_SetPriority(EXTI0_1_IRQn, 0);
```

Добавьте вызов данной функции в `main`. Напишите обработчик для внешнего прерывания:

```c
void EXTI0_1_IRQHandler(void)
{
    //
}
```

В данном обработчике добавьте переключение состояние вывода, подключенного к светодиоду (перед этим напишите функцию `gpio_config` для инициализации вывода). Не забудьте сбросить флаг 
для нулевой линии прерывания с помощью ` LL_EXTI_ClearFlag_0_31(LL_EXTI_LINE_0)`, иначе программа никогда не вернется в основной цикл программы. 

Заметьте, что на кнопке присутствует дребезг и поведение программы не всегда корректно.

## Системный таймер

Чтобы решить проблему с антидребезгом, используйте таймер для отчета времени. В первую очередь добавьте заголовочные файлы `stm32f0xx_ll_utils.h` и `stm32f0xx_ll_cortex.h` для работы с системным таймером.

Реализуйте функцию `systick_config`, где выполняется инициализация системного таймера. В первую очередь настройте предделитель, включите таймер и разрешите прерывание. Так как системный таймер является частью ядра, включать его в 
`NVIC` не нужно, включение производится непосредственно в регистре `SYST_CSR` c помощью метода `LL_SYSTICK_EnableIT`:

```c
/*
 * Частота 1 КГц (выставляются регистр-перезагрузка SYST_RVR и производится
 * включение таймера в SYST_CSR)
 * Входные параметры для функции это текущая частота МК и желаемая частота таймера
 */
LL_InitTick(48000000, 1000);
/*
 * Разрешение прерываний в модуле таймера в SYST_CSR
 */
LL_SYSTICK_EnableIT();

/*
 * В данном случае приоритет будет выставлен через регистр SCB, а не регистры NVIC, так как
 * номер прерываний -1 (системное прерывание)
 */
NVIC_SetPriority(SysTick_IRQn, 0);
```

Добавьте обработчик для таймера:

```c
void SysTick_Handler(void)
{
    //
}
```

Обработчик вызывается каждую миллисекунду. Чтобы помигать светодиодом, используя таймер, добавьте переключение в данном обработчике. Дополнительно добавьте переменную-счетчик, чтобы снизить частоту мерцания с 1 Кгц до 1 Гц.
Теперь светодиод мигает псевдопараллельно исполнению основного цикла `main`.

После проверки роботоспособности таймера, создайте глобальную переменную `milliseconds` и инкрементируйте ее значение в обработчике.

Вернитесь к обработчику внешнего прерывания. Чтобы реализовать антидребезг, создайте две переменные с текущим значением времени в мс и предыдущим значением. Каждый раз в обработчике проверяйте разницу между предыдущим и текущим временем, если больше 50 мс, значит можно считать, что кнопка была нажата:

```c
void EXTI0_1_IRQHandler(void)
{
    int ms = milliseconds;
    static ms_old = 0;
    
    /*
     * Если разница больше чем 50 между ms_old и ms, то выполнить действие
     */
     
    /* 
     * Обновить значение old_ms и сбросить флаг нулевой линии прерывания
     */
    return;
}
```

Таким образом, задействуя таймер и внешнее прерывания, вам удалось обработать нажатие кнопки. При этом цикл `main` остался пустым.

## Энкодер

Изучив примеры работы с периферией `EXTI` и `SyTick`, напишите программу, которая меняет частоту мерцания светодиода в зависимости от поворотов энкодера.

Для определенности предлагается использовать инкрементальный энкодер с двумя выводами. Инкрементальный энкодер это линейное, либо вращательное электромеханическое устройство, имеющее два выхода: A и B, на которых генерируются импульсы при вращении ручки энкодера.

Инкрементальный энкодер не показывает абсолютное положение ручки энкодера, он только показывает изменения положения, учитывая направление.

<p align="center">
  <img width="600" src="https://github.com/edosedgar/stm32f0_ARM/wiki/encoder.png" alt="encoder.png"/>
  <p align="center"> Сигнал с энкодера (credits: Wikipedia) <p align="center">
      
При вращении сгенерированные импульсы имеют разницу фаз в 90 градусов между выходами A и B. В любой момент времени разница в фазе будет либо положительная, либо отрицательная в зависимости от направления вращения (данное кодирование называется квадратурным). В таком случае, если вращение происходит по часовой стрелке, разница фаз будет +90 градусов. Если вращать энкодер против часовой стрелки, то разница фаз будет -90 градусов. Частота импульсов прямопропорциональна скорости вращения энкодера. На рисунке ниже показана работа роторного инкрементального энкодера.

<p align="center">
  <img width="500" src="https://github.com/edosedgar/stm32f0_ARM/wiki/encoder_anim.gif" alt="encoder_anim.gif"/>
  <p align="center"> Работа энкодера (credits: Wikipedia) <p align="center">

В механическом инкрементальном энкодере используются скользящие контакты для генерации выходного сигнала. Внутреннее кольцо контактов подключено к выходу A, а внешнее к выходу B. При повороте ручки скользящий контакт по радиусу замыкает контакты на кольцах на землю, либо на питание в зависимости от того, куда подключен средний вывод. Для определенности положим, что средний вывод подключен к питанию, а выходы A и B подтянуты через резистор к земле. При замыкании контактов состояние выводов A и B будет переходить в лог. единицу.

Для декодирования входной последовательности импульсов в направление вращения используется квадратурный декодер. Суть квадратурного декодера состоит в том, чтобы каждый раз опрашивать текущее состояние выходов A и B, далее сохранять его вместе с предыдущем состоянием и предпринимать какие-то действия на основе этих данных. Если посмотреть на выходную диаграмму энкодера, у него есть некоторый набор разрешенных состояний.

Рассмотрим следующий пример для вращения по часовой стрелке (CW):

    
|  A_old  |  B_old  |  A_new  |  B_new  |  Out  |
|:-------:|:-------:|:-------:|:-------:|:-------:|
|  0  |  0  |  1  |  0  |  CW   |
|  1  |  0  |  1  |  1  |  CW   |
|  1  |  1  |  0  |  1  |  CW   |
|  0  |  1  |  0  |  0  |  CW   |

При вращении против часовой (CCW):

    
|  A_old  |  B_old  |  A_new  |  B_new  |  Out  |
|:-------:|:-------:|:-------:|:-------:|:-------:|
|  0  |  0  |  0  |  1  |  CCW   |
|  0  |  1  |  1  |  1  |  CCW   |
|  1  |  1  |  1  |  0  |  CCW   |
|  1  |  0  |  0  |  0  |  CCW   |


Все остальные 8 состояний ошибочные. Чтобы представить это в виде кода, можно создать следующий массив:

```c
int8_t states[] = {0,-1,1,0,1,0,0,-1,-1,0,0,1,0,1,-1,0};
```

Индексом для данного массива будет 4-битное число, состоящее из предыдущего и текущего состояний (A_old, B_old, A_new, B_new). `1` в данном массиве значит, что вращение было по часовой стрелке, `-1` - против, а `0` обозначает ошибочное состояние. Можно представить, что программа ходит окном из двух последовательных состояний и пытается выяснить направление вращения. Далее значения массива по индексам состояний (предыщее + текущее) суммируются в какой-то переменной `m`. Как только значение переменной `m` достигнет порогового значения, скажем 4, программа может уверенно сказать, что направление было по часовой стрелке, а при -4 - против часовой.

Теперь необходимо запрограммировать данный алгоритм на микроконтроллере, используя внешние прерывания. Подключите энкодер к пинам `GPIOA 0` и `GPIOA 1`. Первым делом сконфигурируйте линии `0` и `1` модуля `EXTI` в `exti_config`:

```c
LL_SYSCFG_SetEXTISource(LL_SYSCFG_EXTI_PORTA, LL_SYSCFG_EXTI_LINE1);
LL_SYSCFG_SetEXTISource(LL_SYSCFG_EXTI_PORTA, LL_SYSCFG_EXTI_LINE0);
LL_EXTI_EnableIT_0_31(LL_EXTI_LINE_1);
LL_EXTI_EnableIT_0_31(LL_EXTI_LINE_0);
```

Не забудьте подать тактирование на модуль `SYSCFG`, как было показано ранее. Далее с помощью функций `LL_EXTI_EnableFallingTrig_0_31` и `LL_EXTI_EnableRisingTrig_0_31` настройте генерирование прерывания по нарастающему и спадающему фронтам (ни одно переключение выхода энкодера не должно быть пропущено). Далее включите прерывание `EXTI0_1_IRQn` в модуле `NVIC`, используя уже известные вам функции из LL.

Далее включите внутренюю подтяжку каналов на землю в функции `gpio_config`:

```c
LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOA);
LL_GPIO_SetPinPull(GPIOA, LL_GPIO_PIN_1, LL_GPIO_PULL_DOWN);
LL_GPIO_SetPinPull(GPIOA, LL_GPIO_PIN_0, LL_GPIO_PULL_DOWN);
```

Следующим шагом напишите правильный обработчик `EXTI0_1_IRQHandler`, так чтобы он сохранял текущее и предыдущее состояния
и накапливал значения из массива `states`:

```c
void EXTI0_1_IRQHandler(void)
{
    /*
     * Массив сделан статическим, чтобы он не высвобождался из памяти между
     * вызовами функции
     */
    static int8_t states[] = {...};
    
    /* 
     * Заведите переменную для хранения текущего состояния энкодера
     */
     
    /*
     * Заведите переменную для хранения двух последних состояний
     * (статическая)
     */
     
    /*
     * Заведите переменную, чтобы накапливать состояния энкодера
     * (статическая)
     */
     
    /*
     * Сохраните текущее состояние PA0 и PA1
     * с помощью LL_GPIO_ReadInputPort.
     * Используйте лог. "И" с полученным значение, чтобы сохранить
     * только ДВА последних бита
     */
     
    /*
     * Сдвиньте на два бита вправо переменную с двумя посл. состояними
     * и добавьте в младшие два бита новое состояние линии 0 и 1. С
     * помощью лог. "И" оставьте только последние 4 бита от результата.
     * Запишите в переменную с двумя посл. состояниями полученный результат.
     */
     
    /*
     * Получите текущее направление вращения энкодера из массива по адресу
     * переменной с двумя посл. состояниями. Просуммируйте значение переменной
     * с состоянием энкодера с полученным значением из массива.
     */
     
    if (состояние энкодера == 4) {
        // Поворот по часовой стрелке
        состояние энкодера = 0;
    }

    if (состояние энкодера == -4) {
        // Поворот против часовой стрелке
        состояние энкодера = 0;
    }
    
    /*
     * Не забудьте очистить флаги для линий 0 и 1 в модуле EXTI
     */
    LL_EXTI_ClearFlag_0_31(...);
    LL_EXTI_ClearFlag_0_31(...);
    return;
}
```

Для проверки работоспособности, попробуйте включить синий светодиод, когда поворот вправо, и зеленый, когда влево. 
Далее напишите программу, которая меняет частоту мерцания светодиода в зависимости от вращения энкодера. Используйте для этого системный таймер с переменной-делителем в обработчике, как это было сделано ранее для достижения частоты в 1 Гц. При повороте вправо увеличивайте пороговое значение для переменной-делителя, при повороте влево - уменьшайте.

## Динамическая индикация v2.0

На прошлой лабораторной работе вы подключили индикатор к микроконтроллеру. В этой работе сделайте динамическую индикацию на системном таймере, попросту поместив вызов функции `dyn_display` в обработчик системного прерывания.

```c
void SysTick_Handler(void)
{
    dyn_display(digit);
}
```

Теперь индикаторы будут переключаться с частотой 1 КГц. Сделайте переменную `digit` глобальной, чтобы можно было менять значение на индикаторе в любом другом месте кода.

Используя все полученные навыки вместе, напишите программу, которая инкрементирует или декрементирует значение на индикаторе в зависимости от направления вращения энкодера.
